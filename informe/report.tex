\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

% Configuración de listings para Python
\lstset{
    language=Python,
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=none,
    breaklines=true,
    frame=single,
    xleftmargin=2pt,
    xrightmargin=2pt,
    framexleftmargin=2pt,
    framexrightmargin=2pt,
    inputencoding=utf8,
    extendedchars=true,
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
             {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
             {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {ü}{{\"u}}1 {Ü}{{\"U}}1
}

% Teoremas y definiciones
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}{Lema}
\newtheorem{definition}{Definición}
\newtheorem{corollary}{Corolario}

\begin{document}

\title{El Problema del Comerciante Holandés:\\
Análisis de Complejidad e Implementación de Algoritmos}

\author{
\IEEEauthorblockN{Tony Cadahía Poveda, Manuel Alejandro Gamboa Hernández, David Sánchez Iglesias}
\IEEEauthorblockN{Diseño y Análisis de Algoritmos}\\
\IEEEauthorblockA{Universidad de La Habana\\
Facultad de Matemática y Computación\\
Curso 2025-2026}
}

\maketitle

\begin{abstract}
En este trabajo se estudia el Problema del Comerciante Holandés (Dutch Trader Problem, DTP), un problema de optimización combinatoria que modela la planificación de rutas y operaciones comerciales bajo restricciones de tiempo, capacidad y capital. Se presenta una demostración formal de que DTP es NP-completo y NP-duro mediante reducción desde el Problema del Viajante (Traveling Salesman Problem, TSP) y el Problema de la Mochila (Knapsack). Se describe el modelado computacional implementado en Python, y se analizan dos enfoques algorítmicos: un algoritmo de fuerza bruta que garantiza optimalidad y un algoritmo greedy heurístico con optimización local. Los resultados experimentales demuestran el trade-off entre optimalidad y eficiencia computacional.
\end{abstract}

\section{Introducción}

El Problema del Comerciante Holandés (Dutch Trader Problem, DTP) es un problema de optimización combinatoria que integra aspectos del Problema del Viajante (Traveling Salesman Problem, TSP), el Problema de la Mochila (Knapsack Problem), y la planificación bajo restricciones múltiples. El problema modela el escenario de un comerciante que parte del puerto de Ámsterdam con capital inicial, debe visitar otros puertos para comprar y vender mercancías, y debe regresar a Ámsterdam maximizando su capital final.

\subsection{Motivación}

El DTP captura la complejidad de problemas reales en logística y comercio marítimo, donde las decisiones sobre rutas, selección de mercancías y gestión de recursos deben tomarse simultáneamente. La naturaleza multi-objetivo del problema (maximizar beneficio, minimizar tiempo de viaje, respetar restricciones de capacidad) lo convierte en un caso de estudio relevante para el análisis de algoritmos.

\subsection{Contribuciones}

Las principales contribuciones de este trabajo son:
\begin{itemize}
    \item Demostración formal de la NP-completitud y NP-dureza del DTP
    \item Diseño e implementación de un modelo computacional orientado a objetos
    \item Implementación y análisis de un algoritmo exacto de fuerza bruta
    \item Diseño de un algoritmo greedy con optimización local mediante knapsack
    \item Evaluación experimental comparativa de ambos enfoques
\end{itemize}

\section{Definición Formal del Problema}

\begin{definition}[Problema del Comerciante Holandés]
Dada una instancia $I = (G, M, C_0, T_{max}, W_{max}, B_{min})$ donde:
\begin{itemize}
    \item $G = (V, E)$ es un grafo dirigido con $|V| = n+1$ vértices (puertos $0, 1, \ldots, n$), donde $0$ representa Ámsterdam
    \item Para cada arista $(i,j) \in E$ existen funciones de costo $c(i,j) \in \mathbb{R}^+$ y tiempo $t(i,j) \in \mathbb{R}^+$
    \item $M = \{1, 2, \ldots, m\}$ es el conjunto de mercancías
    \item Para cada mercancía $k \in M$ y puerto $p \in V$:
    \begin{itemize}
        \item $P_c[k,p]$: precio al que el puerto compra (comerciante vende)
        \item $P_v[k,p]$: precio al que el puerto vende (comerciante compra)
        \item $O[k,p]$: oferta máxima disponible
        \item $w_k$: peso por unidad
    \end{itemize}
    \item $C_0$: capital inicial del comerciante
    \item $T_{max}$: tiempo máximo de viaje permitido
    \item $W_{max}$: capacidad máxima de bodega
    \item $B_{min}$: capital mínimo requerido al retornar
\end{itemize}

El objetivo es encontrar:
\begin{enumerate}
    \item Una ruta $R = (r_0 = 0, r_1, \ldots, r_s, r_{s+1} = 0)$ que parte y termina en Ámsterdam
    \item Matrices de operaciones $\text{Compras}[k,i]$ y $\text{Ventas}[k,i]$ indicando las cantidades de cada mercancía $k$ compradas/vendidas en el paso $i$ de la ruta
\end{enumerate}

Sujeto a las restricciones:
\begin{align}
\sum_{i=0}^{s} t(r_i, r_{i+1}) &\leq T_{max} \tag{tiempo} \\
\sum_{k \in M} w_k \cdot \text{cargo}_k(i) &\leq W_{max} \quad \forall i \tag{capacidad} \\
\text{capital}(i) &\geq 0 \quad \forall i \tag{solvencia} \\
\text{Compras}[k,i] &\leq O[k, r_i] \quad \forall k, i \tag{oferta} \\
\text{capital}(s+1) &\geq B_{min} \tag{capital mínimo}
\end{align}

Y maximizando:
\begin{equation}
\text{beneficio} = \text{capital}(s+1) - C_0
\end{equation}
\end{definition}

\section{Análisis de Complejidad}

\subsection{NP-Completitud del DTP}

\begin{theorem}
El Problema del Comerciante Holandés es NP-completo.
\end{theorem}

\begin{proof}
La demostración procede en dos pasos: mostrar que DTP $\in$ NP y que DTP es NP-duro.

\textbf{Paso 1: DTP $\in$ NP}

Dado un certificado (una solución candidata) que consiste en:
\begin{itemize}
    \item Una ruta $R = (r_0, r_1, \ldots, r_s, r_{s+1})$
    \item Matrices $\text{Compras}[k,i]$ y $\text{Ventas}[k,i]$
\end{itemize}

Podemos verificar en tiempo polinomial:
\begin{enumerate}
    \item $r_0 = r_{s+1} = 0$ (comienza y termina en Ámsterdam)
    \item $\sum_{i=0}^{s} t(r_i, r_{i+1}) \leq T_{max}$ (tiempo total $O(s)$)
    \item Para cada paso $i$, simular operaciones comerciales:
    \begin{itemize}
        \item Verificar restricción de capacidad: $O(m \cdot s)$
        \item Actualizar capital: $O(m \cdot s)$
        \item Verificar restricción de oferta: $O(m \cdot s)$
    \end{itemize}
    \item $\text{capital}_{\text{final}} \geq B_{min}$
    \item $\text{beneficio} \geq \text{umbral}$ (si es un problema de decisión)
\end{enumerate}

Complejidad total: $O(s \cdot m) = O(n \cdot m)$, polinomial en el tamaño de entrada. Por tanto, DTP $\in$ NP.

\textbf{Paso 2: DTP es NP-duro}

Reducimos el Problema del Viajante (TSP) al DTP. Dado una instancia de TSP con grafo $G=(V,E)$ y función de costo $d: E \to \mathbb{R}^+$, construimos una instancia de DTP:

\begin{itemize}
    \item Usar el mismo grafo $G$ con $c(i,j) = d(i,j)$ y $t(i,j) = d(i,j)$
    \item $M = \{1\}$ (una sola mercancía)
    \item Para cada puerto $p \neq 0$:
    \begin{itemize}
        \item $O[1,p] = 1$ (oferta unitaria)
        \item $P_v[1,p] = 1$, $P_c[1,p] = 1$ (precio constante, sin ganancia)
    \end{itemize}
    \item Puerto 0 (Ámsterdam): $O[1,0] = 0$ (sin oferta)
    \item $w_1 = 0$ (peso cero, sin restricción de capacidad)
    \item $C_0 = \sum_{p \neq 0} 1 = n$ (suficiente para comprar en todos los puertos)
    \item $T_{max} = K$ (límite del TSP)
    \item $W_{max} = n$, $B_{min} = 0$
\end{itemize}

\textbf{Análisis de la reducción:}

Una solución del TSP con costo $\leq K$ corresponde a una ruta en DTP que:
\begin{enumerate}
    \item Visita cada puerto exactamente una vez (por la oferta unitaria)
    \item Cumple $\sum t(r_i, r_{i+1}) = \sum d(r_i, r_{i+1}) \leq K$
    \item Es factible (precios neutros, sin restricciones de capacidad)
\end{enumerate}

Recíprocamente, cualquier solución factible de DTP que visite todos los puertos define una ruta de TSP con el mismo costo.

La reducción es polinomial: $O(n^2 + m \cdot n) = O(n^2)$ para construir las matrices.

Por tanto, TSP $\leq_p$ DTP, y como TSP es NP-completo, DTP es NP-duro.

Combinando ambos pasos: DTP $\in$ NP y DTP es NP-duro $\Rightarrow$ \textbf{DTP es NP-completo}.
\end{proof}

\subsection{NP-Dureza del Problema de Optimización}

El DTP como problema de optimización (maximizar beneficio sin umbral fijo) es NP-duro:

\begin{corollary}
El problema de optimización DTP es NP-duro.
\end{corollary}

\begin{proof}
Si existiera un algoritmo polinomial para resolver el DTP de optimización, podríamos resolver el DTP de decisión (NP-completo) en tiempo polinomial:
\begin{enumerate}
    \item Ejecutar el algoritmo de optimización para obtener $\text{beneficio}_{\text{óptimo}}$
    \item Comparar si $\text{beneficio}_{\text{óptimo}} \geq \text{umbral}$
\end{enumerate}

Esto violaría P $\neq$ NP (asumiendo la conjetura estándar), por tanto el problema de optimización es NP-duro.
\end{proof}

\subsection{Reducción desde Knapsack}

El DTP también contiene como subproblema el Problema de la Mochila (Knapsack):

\begin{lemma}
Knapsack $\leq_p$ DTP
\end{lemma}

\begin{proof}
Dada una instancia de Knapsack con items $(v_i, w_i)$, valores, pesos y capacidad $W$, construir DTP con:
\begin{itemize}
    \item Dos puertos: $V = \{0, 1\}$
    \item Costos y tiempos triviales: $c(0,1) = c(1,0) = 0$, $t(0,1) = t(1,0) = 1$
    \item Mercancías: cada item $i$ es una mercancía con:
    \begin{itemize}
        \item $P_v[i,1] = 0$ (gratis en puerto 1)
        \item $P_c[i,0] = v_i$ (vender en Ámsterdam da el valor)
        \item $O[i,1] = 1$, $w_i$ el peso del item
    \end{itemize}
    \item $W_{max} = W$, $C_0 = \infty$, $T_{max} = 2$
\end{itemize}

La ruta es fija $(0 \to 1 \to 0)$, y el problema se reduce a seleccionar qué items (mercancías) cargar en puerto 1 para maximizar el valor de venta en puerto 0, respetando la capacidad $W$. Esto es exactamente el problema de Knapsack.
\end{proof}

\section{Modelado Computacional}

\subsection{Arquitectura del Sistema}

La implementación sigue un diseño orientado a objetos con clara separación de responsabilidades:

\begin{lstlisting}[caption=Estructura del proyecto]
solver/
    schemas/
        dtp.py          # Estructuras de datos
    models/
        solver.py       # Interfaz abstracta
        brute.py        # Solver exacto
        greedy.py       # Solver heuristico
\end{lstlisting}

\subsection{Esquemas de Datos}

El módulo \texttt{schemas/dtp.py} define las estructuras fundamentales:

\begin{lstlisting}[caption=Clase DTPInstance]
@dataclass(slots=True)
class DTPInstance:
    """Instancia del problema DTP"""
    tiempos: MatrixFloat      # (n+1) x (n+1)
    costos: MatrixFloat       # (n+1) x (n+1)
    precios_compra: MatrixFloat  # m x (n+1)
    precios_venta: MatrixFloat   # m x (n+1)
    oferta_max: MatrixFloat      # m x (n+1)
    pesos: VectorFloat           # m
    
    capacidad_bodega: int
    capital_inicial: int
    tiempo_maximo: int
    umbral_beneficio: float
    capital_minimo: float
\end{lstlisting}

\textbf{Convención de precios:} Los precios están desde la perspectiva del puerto:
\begin{itemize}
    \item \texttt{precios\_compra[k,p]}: precio al que el puerto $p$ compra la mercancía $k$ del comerciante
    \item \texttt{precios\_venta[k,p]}: precio al que el puerto $p$ vende la mercancía $k$ al comerciante
    \item Invariante: $\texttt{precios\_compra} < \texttt{precios\_venta}$ (el puerto compra barato, vende caro)
\end{itemize}

\begin{lstlisting}[caption=Clase DTPSolution]
@dataclass(slots=True)
class DTPSolution:
    """Solución del problema DTP"""
    ruta: tuple[int, ...]        # Secuencia de puertos
    compras: MatrixFloat         # m x len(ruta)
    ventas: MatrixFloat          # m x len(ruta)
    beneficio_final: float
\end{lstlisting}

\subsection{Interfaz Abstracta de Solvers}

El patrón Strategy permite implementar múltiples algoritmos con interfaz uniforme:

\begin{lstlisting}[caption=ABCSolver]
class ABCSolver(ABC):
    @abstractmethod
    def solve(self, instance: DTPInstance) 
              -> DTPSolution:
        """Resuelve la instancia"""
        
    @abstractmethod
    def is_feasible(self, instance: DTPInstance,
                    solution: DTPSolution) -> bool:
        """Verifica factibilidad"""
        
    @abstractmethod
    def evaluate(self, instance: DTPInstance,
                 solution: DTPSolution) -> float:
        """Evalua calidad de solucion"""
\end{lstlisting}

\section{Algoritmo de Fuerza Bruta}

\subsection{Descripción del Algoritmo}

El \texttt{BruteForceSolver} explora exhaustivamente el espacio de soluciones mediante búsqueda en profundidad (DFS):

\begin{algorithm}
\caption{BruteForceSolver}
\begin{algorithmic}[1]
\Procedure{Solve}{$instance$}
    \State $best \gets $ solución trivial
    \ForAll{$perm \in \text{Perm}(\{1, \ldots, n\})$}
        \State $route \gets (0) + perm + (0)$
        \If{$\text{Time}(route) > T_{max}$}
            \State \textbf{continue}
        \EndIf
        \State $cand \gets \Call{SearchTrades}{route}$
        \If{$cand.\text{benef} > best.\text{benef}$}
            \State $best \gets cand$
        \EndIf
    \EndFor
    \State \Return $best$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{SearchTrades}
\begin{algorithmic}[1]
\Procedure{SearchTrades}{$route$}
    \State $best\_cap \gets -\infty$
    \State \Call{DFS}{$0, C_0, \vec{0}, 0$}
    \State \Return solución con $best\_cap$
\EndProcedure
\Procedure{DFS}{$i, cap, cargo, t$}
    \If{$i > 0$}
        \State $cap \gets cap - c(route[i-1], route[i])$
        \State $t \gets t + t(route[i-1], route[i])$
        \If{$cap < 0 \lor t > T_{max}$}
            \State \Return
        \EndIf
    \EndIf
    \State $p \gets route[i]$
    \ForAll{$v \in \text{Ventas}(cargo)$}
        \State $cap' \gets cap + \sum_k v[k] \cdot P_c[k, p]$
        \ForAll{$c \in \text{Compras}(cap', p)$}
            \If{$\text{Fact}(cap', cargo', W, O)$}
                \If{$i = |route|-1$} 
                    \State $best\_cap \gets \max(best\_cap, cap')$
                \Else
                    \State \Call{DFS}{$i+1, cap', cargo', t$}
                \EndIf
            \EndIf
        \EndFor
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Análisis de Complejidad}

\textbf{Complejidad temporal:}
\begin{align*}
T(n,m) &= n! \cdot \underbrace{\prod_{i=1}^{n+1} \prod_{k=1}^m (O[k,r_i] + 1)}_{\text{combinaciones de comercio}} \\
&= O(n! \cdot \exp(m \cdot n \cdot \bar{O}))
\end{align*}

donde $\bar{O}$ es la oferta promedio. La complejidad es factorial en $n$ y exponencial en $m$.

\textbf{Complejidad espacial:} $O(m \cdot n)$ para almacenar las matrices de operaciones.

\textbf{Optimalidad:} El algoritmo garantiza encontrar la solución óptima global al explorar exhaustivamente todas las combinaciones factibles.

\subsection{Optimizaciones Implementadas}

\begin{enumerate}
    \item \textbf{Poda por tiempo:} Descarta rutas cuyo tiempo mínimo (sin comercio) excede $T_{max}$
    \item \textbf{Poda por capital:} Termina ramas donde el capital se vuelve negativo
    \item \textbf{Cálculo incremental:} Mantiene estado de capital y cargo entre pasos
\end{enumerate}

\section{Algoritmo Greedy con Optimización Local}

\subsection{Diseño del Algoritmo}

El \texttt{GreedySolver} aplica una estrategia golosa en dos niveles:

\begin{enumerate}
    \item \textbf{Selección de puerto:} Elige el siguiente puerto no visitado minimizando costo/tiempo
    \item \textbf{Operaciones comerciales:} En cada puerto, resuelve un subproblema de knapsack para optimizar compras
\end{enumerate}

\begin{algorithm}
\caption{GreedySolver}
\begin{algorithmic}[1]
\Procedure{Solve}{$inst$}
    \State $cur \gets 0$, $cap \gets C_0$, $cargo \gets \vec{0}$
    \State $t \gets 0$, $vis \gets \{0\}$, $route \gets [0]$
    \State $nxt \gets \Call{SelPort}{cur, vis, cap, t}$
    \State $(v, c, cap, cargo) \gets \Call{Trade}{cur, cargo, cap, nxt}$
    \While{$|vis| \leq n$}
        \State $nxt \gets \Call{SelPort}{cur, vis, cap, t}$
        \If{$nxt = \texttt{None}$}
            \State \textbf{break}
        \EndIf
        \State $cap \gets cap - c(cur, nxt)$
        \State $t \gets t + t(cur, nxt)$
        \If{$cap < 0 \lor t > T_{max}$}
            \State \textbf{break}
        \EndIf
        \State $cur \gets nxt$, $vis.\text{add}(nxt)$
        \State $route.\text{append}(nxt)$
        \State $la \gets \Call{SelPort}{cur, vis, cap, t}$
        \State $(v, c, cap, cargo) \gets \Call{Trade}{cur, cargo, cap, la}$
    \EndWhile
    \State \Return $\Call{Build}{route, c, v, cap}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Selección de Puerto}

\begin{algorithm}
\caption{SelPort}
\begin{algorithmic}[1]
\Procedure{SelPort}{$cur, vis, cap, time$}
    \State $bp \gets \texttt{None}$, $bs \gets \infty$
    \ForAll{$p \in \{1, \ldots, n\} \setminus vis$}
        \State $cst \gets c(cur, p)$, $tm \gets t(cur, p)$
        \If{$cap < cst \lor time + tm > T_{max}$}
            \State \textbf{continue}
        \EndIf
        \State $s \gets \begin{cases}
            cst & \text{min\_cost} \\
            tm & \text{min\_time} \\
            \frac{cst}{\max(c)} + \frac{tm}{\max(t)} & \text{combined}
        \end{cases}$
        \If{$s < bs$}
            \State $bs \gets s$, $bp \gets p$
        \EndIf
    \EndFor
    \State \Return $bp$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Optimización de Compras mediante Knapsack Greedy}

En cada puerto, el comerciante debe decidir qué comprar sabiendo que:
\begin{itemize}
    \item Venderá todo el cargo en el próximo puerto visitado
    \item El próximo puerto ya fue seleccionado por la heurística greedy
\end{itemize}

Esto se modela como un problema de knapsack con doble restricción (capital y capacidad):

\begin{algorithm}
\caption{KnapGreedy}
\begin{algorithmic}[1]
\Procedure{KnapGreedy}{$cur, nxt, cap, W$}
    \State $opp \gets \text{[]}$ 
    \ForAll{$k \in M$}
        \State $pb \gets P_v[k, cur]$, $ps \gets P_c[k, nxt]$
        \State $pft \gets ps - pb$
        \If{$pft \leq 0$}
            \State \textbf{continue}
        \EndIf
        \State $mu \gets \min(O[k,cur], cap/pb, W/w_k)$
        \State $r \gets pft/w_k$
        \State $opp.\text{append}((k, r, pft, pb, w_k, mu))$
    \EndFor
    \State Ordenar $opp$ por $r$ descendente
    \State $C \gets \vec{0}$, $cr \gets cap$, $wr \gets W$
    \ForAll{$(k, r, pft, p, w, mu) \in opp$}
        \State $q \gets \min(mu, cr/p, wr/w)$
        \State $q \gets \lfloor q \rfloor$
        \If{$q > 0$}
            \State $C[k] \gets q$
            \State $cr \gets cr - q \cdot p$
            \State $wr \gets wr - q \cdot w$
        \EndIf
    \EndFor
    \State \Return $C$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Garantía de capital para viaje:} Antes de comprar, se reserva el costo del viaje:
\begin{lstlisting}
travel_cost = instance.costos[port, next_port]
capital_disponible = capital - travel_cost
compras = KnapsackGreedy(..., capital_disponible, ...)
\end{lstlisting}

\subsection{Análisis de Complejidad}

\textbf{Complejidad temporal:}
\begin{itemize}
    \item Selección de puertos: $O(n^2)$ (en cada paso, revisar $O(n)$ puertos)
    \item Por cada puerto visitado:
    \begin{itemize}
        \item Vender cargo: $O(m)$
        \item Knapsack greedy: $O(m \log m)$ (ordenamiento por ratio)
    \end{itemize}
    \item Total: $O(n^2 + n \cdot m \log m) = O(n^2 + nm\log m)$
\end{itemize}

\textbf{Complejidad espacial:} $O(m \cdot n)$ para matrices de operaciones.

\textbf{Garantías:} El algoritmo no garantiza optimalidad global, pero provee:
\begin{enumerate}
    \item Soluciones factibles (respeta todas las restricciones)
    \item Optimalidad local en el subproblema de knapsack (greedy es óptimo para knapsack fraccional, aproximado para knapsack entero)
    \item Ejecución en tiempo polinomial
\end{enumerate}

\section{Resultados Experimentales}

\subsection{Instancias de Prueba}

Se diseñaron instancias específicas para evaluar diferentes aspectos:

\begin{table}[h]
\centering
\caption{Características de las instancias de prueba}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Instancia} & \textbf{Puertos} & \textbf{Mercancías} & \textbf{$C_0$} & \textbf{$T_{max}$} \\
\hline
TINY & 2 & 2 & 500 & 100 \\
SMALL & 3 & 2 & 1000 & 180 \\
MEDIUM & 5 & 3 & 3000 & 300 \\
\hline
\end{tabular}
\end{table}

\textbf{Descripción de las instancias:}
\begin{itemize}
    \item \textbf{TINY:} Instancia mínima para validación y comparación con fuerza bruta.
    \item \textbf{SMALL:} Instancia pequeña con complejidad moderada.
    \item \textbf{MEDIUM:} Instancia mediana que evalúa el desempeño de metaheurísticas.
\end{itemize}

\subsection{Comparación de Algoritmos}

\begin{table}[h]
\centering
\caption{Resultados comparativos de beneficio final}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Instancia} & \textbf{Brute Force} & \textbf{Greedy} & \textbf{ACO} & \textbf{GA+Beam} \\
\hline
TINY & 417.00 & 400.00 & 417.00 & 417.00 \\
SMALL & --- & 420.00 & 420.00 & 420.00 \\
MEDIUM & --- & 1900.00 & 1950.00 & 1920.00 \\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Tiempos de ejecución}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Instancia} & \textbf{Brute Force} & \textbf{Greedy} & \textbf{ACO} & \textbf{GA+Beam} \\
\hline
TINY & 1719.91s & 79.2$\mu$s & 25.5ms & 37.7ms \\
SMALL & --- & 64.6$\mu$s & 15.6ms & 36.1ms \\
MEDIUM & --- & 53.2$\mu$s & 21.4ms & 53.5ms \\
\hline
\end{tabular}
\end{table}

\textbf{Observaciones:}
\begin{enumerate}
    \item \textbf{Brute Force:} Encuentra el óptimo pero es inviable para $n > 2$ (1720s para TINY)
    \item \textbf{Greedy:} Extremadamente rápido ($<$100$\mu$s) pero subóptimo en instancias complejas
    \item \textbf{ACO:} Mejor calidad (+4.25\% en TINY, +2.63\% en MEDIUM vs Greedy) en tiempo razonable ($<$30ms)
    \item \textbf{GA+Beam:} Calidad competitiva con ACO (+4.25\% en TINY, +1.05\% en MEDIUM vs Greedy)
    \item En SMALL, todos los algoritmos encuentran la misma solución óptima (420)
    \item Las metaheurísticas (ACO, GA+Beam) logran encontrar el óptimo en TINY
\end{enumerate}

\section{Conclusiones y Trabajo Futuro}

\subsection{Conclusiones}

Este trabajo ha presentado un análisis exhaustivo del Problema del Comerciante Holandés:

\begin{enumerate}
    \item Se formalizó el problema y se demostró rigurosamente su NP-completitud y NP-dureza
    \item Se diseñó e implementó un modelo computacional robusto y extensible
    \item Se implementaron dos enfoques algorítmicos con trade-offs claros:
    \begin{itemize}
        \item Fuerza bruta: optimalidad garantizada, escalabilidad limitada
        \item Greedy: eficiencia computacional, calidad aproximada
    \end{itemize}
    \item Los experimentos confirman la intratabilidad práctica del problema para instancias realistas
\end{enumerate}

\subsection{Trabajo Futuro}

Direcciones prometedoras para investigación futura:

\begin{enumerate}
    \item \textbf{Algoritmos avanzados:}
    \begin{itemize}
        \item Branch and Bound con cotas ajustadas
        \item Programación dinámica con reducción de estados
        \item Metaheurísticas (Simulated Annealing, Algoritmos Genéticos, Ant Colony)
        \item Programación Lineal Entera (ILP)
    \end{itemize}
    
    \item \textbf{Mejoras del greedy:}
    \begin{itemize}
        \item Look-ahead de múltiples pasos
        \item Búsqueda local (2-opt, 3-opt para la ruta)
        \item Combinación de múltiples heurísticas (portfolio approach)
    \end{itemize}
    
    \item \textbf{Análisis teórico:}
    \begin{itemize}
        \item Factores de aproximación del greedy
        \item Identificación de casos polinomiales especiales
        \item Cotas inferiores ajustadas para Branch and Bound
    \end{itemize}
    
    \item \textbf{Extensiones del modelo:}
    \begin{itemize}
        \item Precios estocásticos
        \item Eventos dinámicos (tormentas, cambios de oferta)
        \item Múltiples agentes (competencia entre comerciantes)
    \end{itemize}
\end{enumerate}

\section*{Agradecimientos}

Este trabajo fue desarrollado como parte del curso de Diseño y Análisis de Algoritmos en la Facultad de Matemática y Computación de la Universidad de La Habana.

\begin{thebibliography}{9}

\bibitem{garey1979}
M. R. Garey and D. S. Johnson,
\textit{Computers and Intractability: A Guide to the Theory of NP-Completeness},
W. H. Freeman \& Co., 1979.

\bibitem{applegate2006}
D. L. Applegate, R. E. Bixby, V. Chvátal, and W. J. Cook,
\textit{The Traveling Salesman Problem: A Computational Study},
Princeton University Press, 2006.

\bibitem{kellerer2004}
H. Kellerer, U. Pferschy, and D. Pisinger,
\textit{Knapsack Problems},
Springer, 2004.

\bibitem{cormen2009}
T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein,
\textit{Introduction to Algorithms}, 3rd ed.,
MIT Press, 2009.

\bibitem{papadimitriou1998}
C. H. Papadimitriou and K. Steiglitz,
\textit{Combinatorial Optimization: Algorithms and Complexity},
Dover Publications, 1998.

\bibitem{vazirani2001}
V. V. Vazirani,
\textit{Approximation Algorithms},
Springer, 2001.

\end{thebibliography}

\end{document}
